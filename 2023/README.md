# Advent of Code 2023
Advent of code 2023 solutions in python, using various algorithms.

## Kind of problems versus used algorithms

- day 1 - calibration
    - For part 1 you need to find the first and last digit in a line and combine those, to get the sum of all lines.
    - For part 2 the digit can also be written in txt fromat, so with a little help form a dictionary I do the same.
- day 2 - color cubes
    - For part 1 you need to find out which games can be played with a set number of cubes and sum their id's
    - For part 2 you need to get the minimum numbers of cubes for each game and calculate the power of the total games, by summing up the color multiplication.
- day 3 - Gear Ratio's
  - For part 1 you need to find all numbers adjacent to a sign and use those
  - For part 2 you need to find all numbers adjacent to * and if it is exactly 2 multiply and sum those
- day 4 - Scratch cards
  - For part 1 you need to calculate all point won of a collection of scratch cards
  - For part 2 you need to calculate how many cards you end up with after winning
- day 5 - Food production problem
  - For part 1 you need to find the lowest number after you applied a bunch of translation based on ranges
  - For part 2 the seeds are not single seeds, but (in pairs) ranges of numbers, which makes it an optimalization problem. Instead of looping over the billions of seeds, I now split the ranges into (smaller) translated ranges and get the smallest range as smallest
- day 6 - Boat race
  - For part 1 you need to get the multiplication of all the possibilities to win
  - For part 2 you need to get the possibilities of one large race
- day 7 - Camel Poker
  - For part 1 you need to sort your cards upon poker score, and then the total score is the place of the card * the bid
  - For part 2 you need to do the same, but J are now Jokers, which can be any card, so you need to find the best replacement for the joker.
- day 8 - Dessert graph
  - For part 1 you need to find how long the route is from AAA to ZZZ, while following directions
  - For part 2 you need to find how many steps you need to take before all nodes ending on "A" are ending on "Z" at the same time, the least common multiple is used, to optimize
- day 9 - Mirage maintenance
  - For part 1 you need to calculate the next number before the sequence, with the use of a "pyramid"
  - For part 2 you need to calculate the number that came before the sequence the same way
- day 10 - pipe maze
  - For part 1, you need to calculate the farthest point from the startpoint while following the pipe
  - For part 2, you need to find how much of squares the pipe encloses
- day 11 - Cosmic expansion
  - For part 1 we get a universe, where all  rows or columns without stars need to get 2 times as big and then the shortest part between all stars needs to be summed
  - For part 2 we need to do the same, but multiply the empties bij 1000000
- day 12 - Hot springs
  - For part 1 you need to calculate the possible arrangement options for the groups in a string with known ("." or "#") an unknown places ("?")
  - For part 2 you need to do the same but the arrangement (+"?") and the groups get 5 times their size. Added cache to optimize the code
- day 13 - Point of Incidence
  - For part 1 you need to find, where you can fold the map Horizontally or vertically
  - For part 2 you need to find another fold where at you at most need to change 1 tile
- day 14 - Reflector dish
  - For part 1 you need to roll all moving stones to the north and calculate the load
  - For part 2 you need to run a number of cycles, where your roll stones N, W, S, E in each cycle. Seeing the total number is very high I search for the cycle length and use that to find teh load
- day 15 - Lens Library
  - For part 1 you need to calculate the sum of all the HASH values
  - For part 2 you needto put all the lenses in the right boxes based on the HASH value before the = and remove them if there is an -, and calculate the power in the end
- day 16 - The floor will be lava
  - For part 1 you need to calculate how many floor tiles will be lava based on where the beam has been
  - For part 2 you need to calculate what is the best position for the beam to get the most lava tiles
- day 17 - Clumsy Crucible
  - For part 1 you need to find the cheapest path though a matrix, keeping in mind you can only go 3 steps in the same direction, dijkstra is used
  - For part 2 you need to do the same, but take at least 4 and maximal 10 steps in the same direction, dijkstra is used
- day 18 - Lavaduct lagoon
  - For part 1 you need to get all the squares inside the border, a matrix is used
  - For part 2 you need to do the same thing, but the number get so high that matrix cant be used, so use shoelace formula
- day 19 - Aplenty
  - For part 1 you need to get which products are accepted, which i've done by rewriting the sentences into lambda's
  - For part 2 sadly the lambda's where to advanced so I wrote the whole code recursively for ranges.
- day 20 - Pulse propagation
  - for part 1 you need to find how many high and low signals are given after 1000 button pushes
  - for part 2 you need to find the specific low value for one node, so I search for the cycle of nodes it depends on and take the LCM of those
- day 21 - step counter
  - for part 1 you need to find where you can come, I use the chessbord way combined with bfs
  - for part 2 you need to go over a very large grid and do the same. Maybe later optimize
- day 22 - Sand slab
  - for part 1 we needed to find which blocks we could delete without other blocks falling down
  - for part 2 we needed to find for each block how many would fall down and sum those values
- day 23 - Long walk
  - For part 1 we need to find the longest path, while we cannot walk up slopes
  - For part 2 we need to find the longest path, while you can walk up slopes, so many more possabilities excist
- day 24 - Never Tell Me The Odds
  - For part 1, we check if collision of two hailstones is in a window
  - For part 2, the start position of a stone to throw between all hailstones is calculated
- day 25 - Snowoverload
  - For Part 1 we need to find the two subgraphs in a big graph network when you cut three edges

## Todo's
- optimize day 23 part 2 to something usefull
